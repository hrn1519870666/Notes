#### **OSI七层模型与TCP/IP 五层模型**

​		OSI七层：

<img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/osi-7-model.png" alt="OSI 七层模型" style="zoom: 80%;" />

​		TCP/IP四层：网络接口层、网络层、传输层、应用层

​		五层协议体系结构：物理层、数据链路层、网络层、传输层、应用层



#### 每一层的协议和硬件

​		**应用层：HTTP、DNS、**FTP、SMTP

​		**传输层：TCP 、UDP**

​		**网络层：IP、**ICMP、路由器

​		数据链路层：网桥、网卡、交换机

​		物理层：中继器、集线器



#### **TCP与UDP区别和应用场景，基于TCP的协议有哪些，基于UDP的有哪些** 

区别：特点，性能，应用场景，首部字节。

| 类型 |          特点          |          性能          |     应用场景     | 首部字节 |
| ---- | :--------------------: | :--------------------: | :--------------: | :------: |
| TCP  | 面向连接、可靠、字节流 | 传输效率慢、所需资源多 |  文件、邮件传输  |  20-60   |
| UDP  | 无连接、不可靠、报文段 | 传输效率快、所需资源少 | 语音、视频、直播 | 8个字节  |

​	**基于TCP的协议：**HTTP、FTP、SMTP

​	**基于UDP的协议：**DNS、DHCP、RIP



#### **TCP可靠传输的保证** 

​		TCP通过：数据分块、数据包编号、校验和、流量控制、拥塞控制、超时重传、ARP协议等措施保证数据的可靠传输；

1. **数据分块：**应用数据被分割成 TCP 认为最适合发送的数据块。
2. **数据包编号：**TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。可靠，有序，不丢，不重。
3. **校验和：**TCP 将保持它**首部和数据**的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 
4. **流量控制：** TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送缓冲区能接纳的数据。**当接收方来不及处理发送方的数据时，能提示发送方降低发送的速率，防止包丢失。**TCP 使用的流量控制协议是可变大小的滑动窗口协议。 
5. **拥塞控制：** 当网络拥塞时，减少数据的发送。
6. **超时重传：** 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。
7. **ARQ协议：** 停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。



#### TCP三次握手过程，为什么两次不行？

[JavaGuide](https://javaguide.cn/cs-basics/network/tcp-connection-and-disconnection.html#%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B)

​	**三次握手过程：**

​		客户端——发送带有SYN标志的数据包——>服务端 

​		服务端——发送带有SYN/ACK标志的数据包——>客户端

​		客户端——发送带有ACK标志的数据包——>服务端

 **为什么要三次握手?**

三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。

1. **第一次握手** ：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常
2. **第二次握手** ：Client 确认了：**自己发送、接收正常，对方发送、接收正常**；Server 确认了：对方发送正常，自己接收正常
3. **第三次握手** ：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：**自己发送、接收正常**，对方发送、接收正常

​	**为什么两次不行？**

1. **两次握手只能保证单向连接是畅通的。**（为了实现可靠数据传输，通信双方都必须维护一个序列号，以标识发送出去的数据包中，哪些是已经被对方收到的。**三次握手的过程即是通信双方相互告知序列号起始值，并确认对方已经收到了序列号起始值的必经步骤；如果只是两次握手，至多只有连接发起方的起始序列号能被确认，另一方选择的序列号则得不到确认）**
2. 防止已失效的请求报文又传送到了服务端，建立了多余的链接，浪费资源。



#### TCP四次挥手过程，为什么四次？CLOSE-WAIT和TIME-WAIT存在的意义？

**四次挥手过程：**

​	客户端——发送带有FIN标志的数据包——>服务端，关闭与服务端的连接 ，客户端进入FIN-WAIT-1状态

​	服务端收到这个 FIN，它发回一个 ACK，确认序号为收到的序号加1，服务端就进入了**CLOSE-WAIT**状态

​	服务端——发送⼀个FIN数据包——>客户端，关闭与客户端的连接，客户端就进入FIN-WAIT-2状态

​	客户端收到这个 FIN，发回 ACK 报文确认，并将确认序号设置为收到序号加1，**TIME-WAIT**状态

**为什么四次：**

​	因为需要确保客户端与服务端的数据能够完成传输。

**CLOSE-WAIT：**

​	这种状态的含义其实是表示在等待关闭

**TIME-WAIT：**

​	为了解决网络的丢包和网络不稳定所带来的其他问题，确保连接方能在时间范围内，关闭自己的连接



#### 浏览器输入URL并回车的过程以及相关协议

​	**过程：**DNS解析、TCP连接、发送HTTP请求、服务器处理请求并返回HTTP报文、浏览器渲染

| 过程                                                         | 使用的协议            |
| ------------------------------------------------------------ | --------------------- |
| 1、浏览器查找域名对应的IP地址<br />DNS查找过程（浏览器缓存、路由器缓存、DNS缓存） | DNS：获取域名对应的IP |
| 2、根据IP建立TCP连接                                         | TCP：与服务器建立连接 |
| 3、浏览器向服务器发送HTTP请求                                | HTTP：发送请求        |
| 4、服务器响应HTTP响应                                        | HTTP                  |
| 5、浏览器进行渲染                                            |                       |



#### **TCP粘包现象原因和解决方法** 

​	**TCP粘包是指**：发送方发送的若干个数据包到接收方接收时粘成一包。

​	**发送方原因：**

​	TCP默认使用Nagle算法（主要作用：减少网络中报文段的数量），Nagle算法造成了发送方可能会出现粘包问	题。Nagle算法主要做两件事：
​	收集多个小分组，在一个确认到来时一起发送。
​	只有上一个分组得到确认，才会发送下一个分组。

​	**接收方原因：**

TCP接收到数据包时，并不会马上交到应用层进行处理。而是将接收到的数据包保存在接收缓存里，然后应用程序从缓存读取分组。这样一来，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。

​	**解决粘包问题：**

最本质原因在与接收方无法分辨消息与消息之间的边界在哪，通过使用某种方案给出边界，例如：

- 发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。
- 包尾加上\r\n标记。FTP协议正是这么做的。但问题在于如果数据正文中也含有\r\n，则会误判为消息的边界。
- 包头加上包体长度。包头是定长的4个字节，说明了包体的长度。接收对等方先接收包体长度，依据包体长度来接收包体。



#### **重定向和转发区别** 

​	**重定向：redirect：**

1. 地址栏发生变化	

2. 重定向可以访问其他服务器的资源

3. 重定向是两次请求。不能使用request对象来共享数据


​	**转发：forward：**

1. 转发地址栏路径不变

2. 转发只能访问当前服务器下的资源

3. 转发是一次请求，可以使用request对象共享数据
