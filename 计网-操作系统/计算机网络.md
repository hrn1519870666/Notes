#### **OSI七层模型与TCP/IP 四层模型**

OSI七层：

<img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/osi-7-model.png" alt="OSI 七层模型" style="zoom: 80%;" />

TCP/IP四层：网络接口层、网络层、传输层、应用层

五层架构：物理层、数据链路层、网络层、传输层、应用层

**各层协议：**

应用层：**HTTP、DNS**、FTP

传输层**：TCP 、UDP**

网络层：**IP、ARP**、ICMP、路由器

数据链路层：网桥、网卡、交换机

物理层：中继器、集线器



#### TCP与UDP的区别

区别：特点，性能，应用场景，首部字节。

| 类型 |            特点            |          性能          |     应用场景     | 首部字节 |
| ---- | :------------------------: | :--------------------: | :--------------: | :------: |
| TCP  | 面向连接、可靠、面向字节流 | 传输效率慢、所需资源多 |  文件、邮件传输  |  20-60   |
| UDP  | 无连接、不可靠、面向报文段 | 传输效率快、所需资源少 | 语音、视频、直播 | 8个字节  |

面向连接的含义： TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。UDP 在传送数据之前不需要先建立连接。

**基于TCP的协议：**HTTP、FTP、SMTP

**基于UDP的协议：**DNS、DHCP、RIP



#### **TCP可靠传输的保证** 

TCP通过：数据分块、数据包编号、校验和、流量控制、拥塞控制、超时重传、ARP协议等措施保证数据的可靠传输；

1. **数据分块：**应用数据被分割成 TCP 认为最适合发送的数据块。
2. **数据包编号：**TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。可靠，有序，不丢，不重。
3. **校验和：**TCP 将保持它**首部和数据**的检验和。这是一个端到端的校验和，目的是检测数据在传输过程中的任何变化。如果收到段的校验和有差错，TCP 将丢弃这个报文段，并不确认收到此报文段。 
4. **流量控制：** TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端 发送 缓冲区能接纳的数据。**当接收方来不及处理发送方的数据时，能提示发送方降低发送的速率，防止包丢失。**TCP 使用的流量控制协议是可变大小的滑动窗口协议。 
5. **拥塞控制：** 当网络拥塞时，减少数据的发送。
6. **超时重传：** 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。
7. **ARQ协议：** 停止等待协议的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。



#### TCP三次握手过程

<img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/tcp-shakes-hands-three-times.png" alt="TCP 三次握手图解" style="zoom: 80%;" />

**为什么要三次握手?**

三次握手最主要的目的就是双方确认自己与对方的发送与接收都是正常的。

1. 第一次握手 ：Server 确认了对方发送正常，自己接收正常。
2. 第二次握手 ：Client 确认了：**自己发送、接收正常，对方发送、接收正常**；Server 确认了：对方发送正常，自己接收正常（同上）。
3. 第三次握手 ：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：**自己发送、接收正常**，对方发送、接收正常。

**如果第三次握手（Client发送给Server的确认）丢失了，会怎样？**

Client不会超时重传这个ACK，因为TCP不会为没有数据的ACK超时重传（会为有数据的SEQ超时重传）。

Server如果没有收到Client的ACK，会超时重传自己的SYN同步信号，直到收到Client的ACK为止。

**为什么两次握手不行？**

为了实现可靠数据传输，通信双方都必须维护一个序列号，来标识发送出去的数据包中，哪些是已经被对方收到的。

**三次握手的过程是通信双方相互告知序列号起始值，并确认对方已经收到了序列号起始值的必经步骤；如果只是两次握手，至多只有连接发起方的起始序列号能被确认，另一方的序列号则得不到确认。**



#### TCP四次挥手过程

<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30ff59b41c8043e8b9b19c8e0b76a733~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png" style="zoom:67%;" />



**四次挥手过程：**

1. 客户端——发送带有FIN标志的数据包——>服务端，关闭与服务端的连接

2. 服务端收到这个 FIN，发回一个 ACK，确认序号为收到的序号加1，服务端就进入了**CLOSE-WAIT**状态

3. 服务端——发送⼀个FIN数据包——>客户端，关闭与客户端的连接

4. 客户端收到这个 FIN，发回 ACK 报文确认，并将确认序号设置为收到序号加1，客户端进入**TIME-WAIT**状态


**为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？**

因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到自己的数据发完之后再发 FIN，断开服务器到客户端的数据传送。

**如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？**

客户端没有收到 ACK 确认，会重新发送 FIN 请求。

**为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？**

第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。

**CLOSE_WAIT**

**出现时机：**

TCP 连接的**两端都可以发起关闭连接的请求**，若其中**一端发起了关闭连接**，但**另外一端没有关闭连接**，**那么该连接就会处于 CLOSE_WAIT 状态**。

**出现原因：**

通常来说，CLOSE_WAIT 在服务器停留的时间很短，且只会发生在被动关闭连接的一端。除非 Kill 掉进程，否则它是不会消失的，意味着一直占用资源。

如果发现有大量的 CLOSE_WAIT，那就是被动关闭的一方没有及时发送 FIN（根本原因是没有关闭连接），有以下几种可能：

1. 代码问题：请求的时候没有显式关闭 Socket 连接，或者死循环导致关闭连接的代码没有执行到，即 FIN 包没有发出，导致 CLOSE_WAIT 不断累积。
2. 响应过慢 / 超时设置过小：双方连接不稳定，一方 Timeout，另外一方还在处理逻辑，导致 Close 被延后。

**TIME_WAIT**

**出现时机：**

TIME_WAIT出现在**主动发送断开连接请求的一方**(下文中我们称之为客户端)。

客户端在收到服务器端发送的FIN后发送ACK报文，并且进入TIME_WAIT状态，等待2MSL。对于Linux，字段为TCP_TIMEWAIT_LEN硬编码为30秒，对于windows为2分钟(可自行调整)。

**TIME_WAIT的危害**

**占用连接资源**：TIME_WAIT占用的时间内，相同四元组(源地址，源端口，目的地址，目的端口)的连接无法创建。

**TIME_WAIT的解决**

1. 当TIME_WAIT连接数量达到给定的值时，所有的TIME_WAIT连接会被立刻清除，并打印警告信息。但这种粗暴的清理掉所有的连接，意味着有些连接并没有成功等待2MSL，就会造成通讯异常。
2. 修改TCP_TIMEWAIT_LEN值，减少等待时间。



#### 浏览器输入URL并回车的过程

**过程：**DNS解析、TCP连接、发送HTTP请求、服务器处理请求并返回HTTP报文、浏览器渲染

| 过程                                                         | 使用的协议                                                   |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 浏览器查找域名对应的IP地址<br />DNS查找过程（浏览器缓存、本地hosts、本地DNS服务器、DNS根服务器、顶级域DNS服务器、权威DNS服务器） | DNS：获取域名对应的IP                                        |
| 根据IP建立TCP连接                                            | TCP：与服务器建立连接                                        |
| 浏览器向服务器发送HTTP请求                                   | HTTP：发送请求<br />IP:建立TCP连接时，需要发送数据，发送数据在网络层使用IP协议<br />OSPF（开放最短路径优先协议）:IP数据包在路由器之间，路由选择使用OSPF协议<br />ARP:路由器在与服务器通信时，需要将IP地址转换为MAC地址 |
| 服务器响应HTTP响应                                           |                                                              |
| 浏览器进行渲染                                               |                                                              |



#### DNS解析过程

浏览器不能直接通过域名找到对应的服务器 IP 地址，所以需要进行 DNS 解析，查找到对应的 IP 地址进行访问。

1. 在浏览器中输入 hzfe.org 域名，（浏览器）检查缓存，（操作系统检查）本地的 hosts 文件中，是否有这个网址记录，有则从记录里面找到对应的 IP 地址，完成域名解析。
2. 检查本地 DNS 服务器是否缓存该网址记录，有则返回解析结果，完成域名解析。
3. 本地 DNS 服务器发送查询报文至根 DNS 服务器，根 DNS 服务器收到请求后，用顶级域 DNS 服务器地址进行响应。
4. 本地 DNS 服务器发送查询报文至顶级域 DNS 服务器。顶级域 DNS 服务器收到请求后，用权威 DNS 服务器地址进行响应。
5. 本地 DNS 服务器发送查询报文至权威 DNS 服务器，权威 DNS 服务器收到请求后，用 hzfe.org 的 **IP 地址**进行响应，完成域名解析。

从请求主机到本地 DNS 服务器的查询是递归查询（本地DNS服务器代替请求主机进行查询），本地DNS 服务器获取到所需映射的查询过程是迭代查询。



<img src="https://ask.qcloudimg.com/http-save/yehe-4474523/eb1b6b726e6cbe7c04beb6b7885202e4.png?imageView2/2/w/2560/h/7000" alt="img" style="zoom: 50%;" />

#### hosts文件是什么？

hosts文件能够把一些用户较为常用的网址和对应的ip地址对应起来，只要用户在浏览器中输入网址，就能够自动从hosts文件中找到该网址的ip地址。

作用：

1. 加快域名解析的速度。
2. 屏蔽特定网站：把该网站的域名映射到错误的IP或自己计算机的IP，这样就不用访问了。比如不想访问http://www.baidu.com，在hosts写上以下内容：

```bash
127.0.0.1 http://www.baidu.com
0.0.0.0 http://www.baidu.com
```

这样计算机解析域名就解析到本机或错误的IP，达到了屏蔽的目的。


#### **TCP粘包现象原因和解决方法** 

​	**TCP粘包是指**：发送方发送的若干个数据包到接收方接收时粘成一包。

​	**发送方原因：**

​	TCP默认使用Nagle算法：
​	收集多个小分组，在一个确认到来时一起发送。
​	只有上一个分组得到确认，才会发送下一个分组。

​	**接收方原因：**

TCP接收到数据包时，并不会马上交到应用层进行处理。而是将接收到的数据包保存在接收缓存里，然后应用程序从缓存读取分组。这样一来，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。

​	**解决粘包问题：**

最本质原因在与接收方无法分辨消息与消息之间的边界在哪，通过使用某种方案给出边界，例如：

- 发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。
- 包尾加上\r\n标记。FTP协议正是这么做的。但问题在于如果数据正文中也含有\r\n，则会误判为消息的边界。
- 包头加上包体长度。包头是定长的4个字节，说明了包体的长度。接收对等方先接收包体长度，依据包体长度来接收包体。



#### **重定向和转发区别** 

​	**重定向：redirect：**

1. 地址栏发生变化	

2. 重定向可以访问其他服务器的资源

3. 重定向是两次请求。不能使用request对象来共享数据


​	**转发：forward：**

1. 转发地址栏路径不变

2. 转发只能访问当前服务器下的资源

3. 转发是一次请求，可以使用request对象共享数据
