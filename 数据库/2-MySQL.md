# MySQL

## 一、索引

### B+树原理

#### 1. 数据结构

在 B+ Tree 中，**一个节点中的 key 从左到右非递减排列。**

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/33576849-9275-47bb-ada7-8ded5f5e7c73.png" width="350px"> </div><br>

各种树的数据结构：https://blog.csdn.net/qq_21993785/article/details/80576642

#### 2. 与红黑树的比较

**（一）B+ 树有更低的树高，IO次数更少**

（平衡树的树高 O(h)=O(log<sub>d</sub>N)，其中 d 为每个节点的出度。**红黑树的出度为 2，**）而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多。（索引存储在磁盘中，每一次查找意味着要做一次IO操作）**索引树的高度对应IO次数，高度越低，磁盘IO的次数越少。**

**（二）磁盘预读原理**

**数据库系统将索引的一个节点的大小设置为页的大小，使得一次 IO 就能完全载入一个节点。**



#### 3.与B树的比较

（一）B+树非叶子节点不存储数据，在相同的数据量下，B+树更加矮壮。（数据都存储在叶子节点上，非叶子节点的存储能存储更多的索引，所以整棵树就更加矮壮）

（二）**B+树所有的data域在叶子节点，这样遍历叶子节点就能获得全部数据。并且所有叶子节点之间都有一个指针，能进行区间访问。**在数据库中基于范围的查询是非常频繁的，而B树不支持这样的遍历操作。



### 索引分类

#### 功能分类

**普通索引：**允许数据重复，允许为 NULL ，一张表可以创建多个普通索引。

**唯一索引：**不允许数据重复，允许为 NULL，一张表可有多个唯一索引，索引列的值必须唯一。如果是组合索引，则列值的组合必须唯一。

**主键索引：**一张表只能有一个主键索引，不允许重复、不允许为 NULL。

**全文索引：**它查找的是文本中的关键词，主要用于全文检索。



#### 列数分类

**单例索引：**一个索引只包含一个列，一个表可以有多个单例索引。

**组合（联合）索引：**一个组合索引包含两个或两个以上的列。查询的时候遵循 “最左前缀”原则，即使用 where 时，条件要按照建立索引时字段的排列方式放置，索引才会生效。

最左匹配原则：https://www.cnblogs.com/-mrl/p/13230006.html

当创建 (a,b,c) 联合索引时，相当于创建了 (a) 单列索引、(a,b) 联合索引以及 (a,b,c) 联合索引。要想索引生效的话，只能使用 a 和 a,b 和 a,b,c 这三种组合（a,c 组合也可以，但实际上只用到了 a 的单列索引，c 并没有用到）。



#### 物理分类

 **聚簇索引：**将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据。

 **非聚簇索引（也称辅助索引或二级索引）** ：将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置。

 聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。



### 索引优化

#### 1. 独立的列

在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。

例如下面的查询不能使用 actor_id 列的索引：

```sql
SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
```

#### 2. 多列索引

在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。

```sql
SELECT film_id, actor_ id FROM sakila.film_actor
WHERE actor_id = 1 AND film_id = 1;
```

#### 3. 索引列的顺序

让选择性最强的索引列放在前面。

索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。

例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。

```sql
SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,
COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,
COUNT(*)
FROM payment;
```

```html
   staff_id_selectivity: 0.0001
customer_id_selectivity: 0.0373
               COUNT(*): 16049
```

#### 4.前缀索引

当要索引的列字符很多时，索引会很大且变慢，这时可以只索引列开始的部分字符串，节约索引空间，提高索引效率 。

#### 5.覆盖索引（又称索引覆盖）

一个索引包含查询中用到的所有字段（也就是说，**查询的列和索引的列一致**），称为“覆盖索引”。

使用覆盖索引，MySQL 只需要通过索引就可以查找和返回查询所需要的数据，而不必在使用索引处理数据之后再进行回表操作。覆盖索引可以一次性完成查询工作，有效减少IO，提高查询效率。

查询中应该尽量使用覆盖索引，减少使用 `select * from`。



### 索引失效的各种情况

**1.在索引列上做任何操作：**计算，函数，自动/手动转换类型，该列的索引将不起作用。

计算：select * from test where id-1=9;

函数：substring(字段名,1,2)='xxx'；

类型转换：

select * from test where number=1; //错误的写法，varchar类型的number会自动转换为int类型；

select * from test where number='1'; //正确的写法；

由于表的字段number定义为varchar2(20),但在查询时把该字段作为number类型以where条件传给Oracle,这样会导致索引失效。 

**2.like以通配符开头：**('%abc')

**3.or语句前后没有同时使用索引。**当or左右查询字段只有一个是索引，该索引失效，只有当or左右查询字段均为索引时，才会生效。

**4.使用not in ,not exist等语句。**



## 三、存储引擎

### InnoDB

是 MySQL 默认的事务型存储引擎。实现了四个标准的隔离级别，默认级别是可重复读。



### InnoDB和MyISAM对比

- **事务：**InnoDB支持事务，MyISAM不支持。
- **并发：**InnoDB 支持行级锁和表级锁，MyISAM 只支持表级锁。
- **索引：**

InnoDB是**聚簇索引，**使用B+Tree作为索引结构，数据文件和索引绑在一起。必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。

MyISAM是**非聚簇索引，**也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。

也就是说：**InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。**

- 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
- 其它特性：MyISAM 支持压缩表和空间数据索引。



### 如何选择？

1. 是否要支持事务，如果要请选择InnoDB，如果不需要可以考虑MyISAM；

2. 如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读也有写，使用InnoDB。

3. 系统崩溃后，MyISAM恢复起来更困难，能否接受。



### **InnoDB为什么推荐使用自增ID作为主键？**

自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树频繁合并和分裂。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。



## 四、主从复制和读写分离

在实际的生产环境中，如果对MySQL数据库的读和写都在一台数据库服务器中操作，不能满足需求。因此，一般**通过主从复制的方式来同步数据，再通过读写分离来提升数据库的并发负载能力。**

![img](https://img2018.cnblogs.com/blog/1819383/201909/1819383-20190928143232058-993296824.png)

### 主从复制

主从复制是用来建立一个和主数据库完全一样的数据库环境（从数据库）。

**主从复制的作用（好处）**

 1.在从服务器进行**查询，**降低主服务器压力;
 2.在从服务器进行**备份，**避免备份期间影响主服务器服务;
 3.当主服务器出现问题时，可以切换到从服务器。

**主从复制的原理**

数据库有个bin-log二进制文件，记录了所有sql语句。我们的目标就是把主数据库的bin-log文件的sql语句复制过来，让其在从数据库的relay-log（重做日志）中再执行一次。

具体需要三个线程来操作：

**bin-log输出线程:**每当有从库连接到主库的时候，主库都会创建一个线程然后发送bin-log内容到从库。

在从库里，当复制开始的时候，从库就会创建两个线程进行处理：
**从库I/O线程:**从库创建一个I/O线程，该线程连接到主库并**请求**主库发送bin-log里面的更新记录到从库。从库I/O线程**读取**主库的bin-log输出线程发送的更新，并**拷贝到本地**文件，其中包括relay-log文件。

**从库SQL线程:**从库创建一个SQL线程，这个线程读取relay-log的更新事件并执行。


拥有多个从库的主库为每一个从库创建一个bin-log输出线程，每一个从库都有它自己的I/O线程和SQL线程。


### 读写分离

读写分离就是只在MySQL主服务器上写，只在MySQL从服务器上读。通过数据库复制，将更新的信息同步到从数据库。



## 五、Explain 

**Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。**

比较重要的字段有：

- **select_type : 查询类型，有简单查询、联合查询、子查询等**
- **key : 使用的索引**
- **rows : 扫描的行数**



## 六、补充

MySQL的如何保证事务

count(1) count(*) count(列值)的区别



### 一条SQL语句在MySQL中如何执行的

[一条SQL语句在MySQL中如何执行的](<https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485097&idx=1&sn=84c89da477b1338bdf3e9fcd65514ac1&chksm=cea24962f9d5c074d8d3ff1ab04ee8f0d6486e3d015cfd783503685986485c11738ccb542ba7&token=79317275&lang=zh_CN#rd>)

### 一条SQL语句执行得很慢的原因有哪些？

[腾讯面试：一条SQL语句执行得很慢的原因有哪些？---不看后悔系列](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485185&idx=1&sn=66ef08b4ab6af5757792223a83fc0d45&chksm=cea248caf9d5c1dc72ec8a281ec16aa3ec3e8066dbb252e27362438a26c33fbe842b0e0adf47&token=79317275&lang=zh_CN#rd)





