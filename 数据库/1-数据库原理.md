## 一、事务

事务指的是满足 **ACID 特性**的一组**操作。**

### ACID

#### 1. 原子性（Atomicity）

**事务被视为不可分割的最小单元，**事务的**所有操作**要么全部成功提交，要么全部失败回滚。

#### 2. 一致性（Consistency）

**数据库在事务执行前后都保持一致性状态。**拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。

#### 3. 隔离性（Isolation）

**一个事务所做的修改**在最终提交以前，对其它事务是不可见的。

#### 4. 持久性（Durability）

**一旦事务提交，则其所做的修改将会永远保存到数据库中。**即使系统发生崩溃，事务执行的结果也不能丢失。



## 二、并发问题

在并发环境下，事务的**隔离性**很难保证，**并发问题是指不考虑隔离性会导致的问题。**

### 丢失修改（两次写）

**一个事务的更新操作被另外一个事务的更新操作替换。**例如：T<sub>1</sub> 和 T<sub>2</sub> 两个事务都对一个数据进行修改，T<sub>1</sub> 先修改并提交生效，T<sub>2</sub> 随后修改，T<sub>2</sub> 的修改覆盖了 T<sub>1</sub> 的修改。（T1、T2指的是不同的事务）

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207221744244.png"/> </div><br>

### 脏读（提交之前读）

**当前事务可以读到另外事务未提交的数据。**例如：T<sub>1</sub> 修改一个数据但未提交，T<sub>2</sub> 随后读取这个数据。如果 T<sub>1</sub> **回滚**，那么 T<sub>2</sub> 读取的数据是脏数据。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207221920368.png"/> </div><br>

### 不可重复读（读改读）

**在一个事务内多次读取同一数据。在这一事务结束前，另一事务也访问了该数据并做了修改，由于第二个事务的修改，第一个事务两次读取的数据可能不一致。**例如：T<sub>2</sub> 读取一个数据，T<sub>1</sub> 对该数据做了修改。如果 T<sub>2</sub> 再次读取这个数据，此时读取的结果和第一次读取的结果不同。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207222102010.png"/> </div><br>

### 幻读（读插读）

幻读本质上也属于不可重复读的情况，T<sub>1</sub> 读取**某个范围**的数据，T<sub>2</sub> **在这个范围内插入新的数据**，T<sub>1</sub> 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207222134306.png"/> </div><br>



## 三、隔离级别

### 未提交读

修改之后即使没有提交，对其它事务也可见。

### 提交读

一个事务只能读取已经提交的事务所做的修改。

### 可重复读

保证在**同一个事务**中多次读取**同一数据**的结果是一样的。MySQL InnoDB 存储引擎的默认隔离级别。

### 可串行化

强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。该隔离级别需要**加锁**实现。

----

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207223400787.png"/> </div><br>



## 四、MVCC

多版本并发控制（Multi-Version Concurrency Control, MVCC）是 **MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。**

未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。

### 基本思想

**维持一个数据的多个版本，使得读写操作没有冲突。**写操作更新最新的版本快照，而读操作只读该事务开始前的数据库的快照，没有互斥关系，这一点和 CopyOnWrite 类似。

**在 MVCC 中事务的修改操作（增删改）会为数据行新增一个版本快照。**

**脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。**在事务进行读取操作时，为了解决脏读和不可重复读问题，**MVCC 规定只能读取已经提交的快照。**

### 底层原理

#### 版本号

- 系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。
- 事务版本号 TRX_ID ：事务开始时的系统版本号。

#### Undo 日志

MVCC 的多版本指的是多个版本的快照，**快照存储在 Undo 日志中，Undo日志通过回滚指针把一个数据行的所有快照连接起来。**（回滚指针指向这条记录的上一个版本）

例如在 MySQL 创建一个表 t，包含主键 id 和一个字段 x。我们先插入一个数据行，然后对该数据行执行两次更新操作。

```sql
INSERT INTO t(id, x) VALUES(1, "a");
UPDATE t SET x="b" WHERE id=1;
UPDATE t SET x="c" WHERE id=1;
```

因为没有使用 `START TRANSACTION` 将上面的操作当成一个事务来执行，根据 MySQL 的 AUTOCOMMIT 机制，每个操作都会被当成一个事务来执行，所以上面的操作总共涉及到三个事务。快照中除了记录事务版本号 TRX_ID 和操作之外，还记录了一个 bit 的 DEL 字段，用于标记是否被删除。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208164808217.png"/> </div><br>



#### ReadView（读视图）

MVCC 维护了一个 ReadView 结构，主要包含了当前系统**未提交的事务列表 TRX_IDs** {TRX_ID_1, TRX_ID_2, ...}，**还有该列表的最小值 TRX_ID_MIN 和 TRX_ID_MAX。**

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208171445674.png"/> </div><br>

在进行 **SELECT 操作**（？）时，根据数据行快照的 TRX_ID 与 TRX_ID_MIN 和 TRX_ID_MAX 之间的关系，从而**判断数据行快照是否可以使用：**

- TRX_ID \< MIN，表示该数据行快照是在当前所有未提交事务之前进行更改的，因此可以使用。

- TRX_ID \> MAX，表示该数据行快照是在事务启动之后被更改的，因此不可使用。
- MIN \<= TRX_ID \<= MAX，需要根据隔离级别再进行判断：
  - 提交读：如果 TRX_ID  在未提交的事务列表 TRX_IDs  列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。
  - 可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。

在数据行快照不可使用的情况下，需要沿着 Undo日志的回滚指针找到下一个快照，再进行上面的判断。

#### 快照读与当前读

##### 1. 快照读

MVCC 的 SELECT 操作是读快照中的数据，不需要进行加锁操作。

##### 2. 当前读

MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。



## 五、Next-Key Locks

Next-Key Locks 是 **MySQL 的 InnoDB 存储引擎的一种锁实现，为了解决幻影读问题。**在可重复读隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。

**Record Locks:**单个行记录上的锁。

**Gap Locks:**间隙锁，锁定一个范围，但不包括记录本身。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。

**Next-Key Locks:**它是 Record Locks 和 Gap Locks 的结合，锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。它锁定一个**左开右闭**区间，例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：

```sql
(-∞, 10]
(10, 11]
(11, 13]
(13, 20]
(20, +∞)
```



## 六、关系数据库设计理论

### 函数依赖

**记 A-\>B 表示 B 函数依赖于 A。**

**对于 A-\>B，如果能找到 A 的真子集 A'，使得 A'-\> B，那么 A-\>B 就是部分函数依赖，否则就是完全函数依赖。**

对于 A-\>B，B-\>C，则 A-\>C 是一个传递函数依赖。

**如果 {A1，A2，... ，An} 是关系的属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。**

### 异常

以下的学生课程关系的函数依赖为 {Sno, Cname} -\> {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。

| Sno | Sname | Sdept | Mname | Cname | Grade |
| :---: | :---: | :---: | :---: | :---: |:---:|
| 1 | 学生-1 | 学院-1 | 院长-1 | 课程-1 | 90 |
| 2 | 学生-2 | 学院-2 | 院长-2 | 课程-2 | 80 |
| 2 | 学生-2 | 学院-2 | 院长-2 | 课程-1 | 100 |
| 3 | 学生-3 | 学院-2 | 院长-2 | 课程-2 | 95 |

**不符合范式的关系，会产生很多异常，主要有以下四种异常：**

- 冗余数据：例如 `学生-2` 出现了两次。
- 插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。
- 删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 `课程-1` 需要删除第一行和第三行，那么 `学生-1` 的信息就会丢失。
- 修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。

### 范式

**范式理论是为了解决以上提到四种异常。**

高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。

#### 1. 第一范式 (1NF)

**属性不可分。**

#### 2. 第二范式 (2NF)

**每个非主属性完全函数依赖于键码。**

可以通过分解来满足。

以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：

- Sno -\> Sname, Sdept
- Sdept -\> Mname
- Sno, Cname-\> Grade

Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。

Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。

<font size=4>  **分解后**  </font>

关系-1

| Sno | Sname | Sdept | Mname |
| :---: | :---: | :---: | :---: |
| 1 | 学生-1 | 学院-1 | 院长-1 |
| 2 | 学生-2 | 学院-2 | 院长-2 |
| 3 | 学生-3 | 学院-2 | 院长-2 |

有以下函数依赖：

- Sno -\> Sname, Sdept
- Sdept -\> Mname

关系-2

| Sno | Cname | Grade |
| :---: | :---: |:---:|
| 1 | 课程-1 | 90 |
| 2 | 课程-2 | 80 |
| 2 | 课程-1 | 100 |
| 3 | 课程-2 | 95 |

有以下函数依赖：

- Sno, Cname -\>  Grade

#### 3. 第三范式 (3NF)

**非主属性不传递依赖于键码。**

上面的 关系-1 中存在以下传递函数依赖：

- Sno -\> Sdept -\> Mname

可以进行以下分解：

关系-11

| Sno | Sname | Sdept |
| :---: | :---: | :---: |
| 1 | 学生-1 | 学院-1 |
| 2 | 学生-2 | 学院-2 |
| 3 | 学生-3 | 学院-2 |

关系-12

| Sdept | Mname |
| :---: | :---: |
| 学院-1 | 院长-1 |
| 学院-2 | 院长-2 |
