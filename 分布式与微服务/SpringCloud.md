# SpringCloud

## 1.前言

```
all in one=====>模块化的开发
	
微服务的四个核心问题：
	这么多服务
	1.客户端怎么访问服务？    API网关
	2.服务之间如何通信？      HTTP,RPC通信
	3.如何治理服务？         注册和发现
	4.服务挂了怎么办？       熔断机制
	
解决方案：
	
	1.Spring Cloud NetFlix 一站式解决方案
		API网关：zuul
		通信：Http通信方式,同步,阻塞
		服务注册和发现：Eureka
		熔断机制：Hystrix
		Netflix五大神兽：Eureka,Ribbon,Feign,Hystrix,Zuul

    2. Apache Dubbo Zookeeper：半自动，需要整合别人的，这个方案并不完善
    	API网关：没有,找第三方组件，比如整合zuul组件,或者自己实现
    	通信：Dubbo 是一个基于Java的高性能的RPC通信框架(性能比Feign强大)
    	服务注册和发现：Zookeeper
    	熔断机制：没有,需要借助Hystrix
    	
    3. Spring Cloud Alibaba：目前最新的一站式解决方案，可更简单的解决上述4个核心问题
```



## 2. 微服务概述

### 什么是微服务？

微服务是一种**架构模式（架构风格），**它将单一的应用程序划分成一组小的服务，每个服务运行在自己独立的进程内，服务之间互相协调，互相配置，为用户提供最终价值，服务之间采用轻量级的通信机制(HTTP或RPC)互相沟通，每个服务都围绕着具体的业务进行构建，并且能够被独立的部署到生产环境中。对具体的一个服务而言，应该根据业务上下文，选择合适的语言，工具(Maven)对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务，可以使用不同的语言来编写服务，也可以使用不同的数据存储。

**核心：将传统的一站式应用，根据业务拆分成一个一个的服务，彻底地去耦合，每个微服务提供单个业务功能，拥有自己独立的数据库。**

### 微服务优缺点

**优点**

- 高内聚，低耦合。每个服务足够内聚，足够小，代码容易理解，这样能聚焦一个指定的业务功能或业务需求。耦合度比较低，不会影响其他模块的开发。
- 不用关注前端开发，直接写后端代码，然后暴露接口，通过组件进行服务通信。
- 配置简单，基本用注解就能实现，不用使用过多的配置文件。
- 能使用不同的语言开发。
- 每个微服务可以有自己的数据库，也可以有统一的数据库。

**缺点**

- 随着服务的增加，运维的压力也在增大；
- 数据一致性问题；
- 系统部署依赖问题；
- 系统集成测试问题；
- 性能和监控问题；

### 微服务技术栈有哪些？

| **微服务技术条目**                         | 落地技术                                                     |
| ------------------------------------------ | ------------------------------------------------------------ |
| **服务开发**                               | SpringBoot、Spring、SpringMVC等                              |
| 服务配置与管理                             | Netfix公司的Archaius、阿里的Diamond等                        |
| **服务注册与发现**                         | Eureka、Zookeeper等                                          |
| **服务调用**                               | Rest、RPC、gRPC                                              |
| **服务熔断器**                             | Hystrix、Envoy等                                             |
| **负载均衡**                               | Ribbon、Nginx等                                              |
| **服务接口调用**(客户端调用服务的简化工具) | Fegin等                                                      |
| **消息队列**                               | Kafka、RabbitMQ等                                            |
| **服务配置中心管理**                       | SpringCloudConfig、Chef等                                    |
| **服务路由(API网关)**                      | Zuul等                                                       |
| 服务监控                                   | Zabbix、Nagios、Metrics、Specatator等                        |
| 全链路追踪                                 | Zipkin、Brave、Dapper等                                      |
| 数据流操作开发包                           | SpringCloud Stream(封装与Redis，Rabbit，Kafka等发送接收消息) |
| 时间消息总栈                               | SpringCloud Bus                                              |
| **服务部署**                               | Docker、Kubernetes等                                         |



## 3. SpringCloud入门概述

### SpringCloud是什么？

SpringCloud是基于SpringBoot提供的一套**微服务解决方案，**包括服务注册与发现，配置中心，服务网关，负载均衡，熔断器，全链路监控等组件。

SpringCloud并没有重复造轮子，它只是将目前各家公司开发的比较成熟的**服务框架组合起来，通过SpringBoot风格进行再封装，屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂，易部署和维护的分布式系统开发工具包。**

### SpringCloud和SpringBoot的关系

- SpringBoot专注于开发单个微服务；
- SpringCloud关注全局的微服务协调治理框架，它将SpringBoot开发的一个个单体微服务，整合并管理起来，为各个微服务之间提供服务。

### Dubbo 和 SpringCloud技术选型

1. **服务通信：Spring Cloud 抛弃了Dubbo的RPC通信，采用的是基于HTTP的REST方式。**这两种方式各有优劣。虽然从一定程度上来说，REST牺牲了服务调用的性能，但也避免了原生RPC带来的问题。而且REST相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这个优点在当下强调快速演化的微服务环境下，显得更加合适。
2. **注册中心：dubbo推荐使用zookeeper，springcloud是Eureka，**也可以是zookeeper。
3. **服务网关：dubbo本身没有实现，**只能通过其他第三方技术整合，**springcloud有Zuul路由网关。**

### SpringCloud重要组件

Eureka：**服务治理**组件，包括**服务端的注册中心和客户端的服务发现**机制；

Ribbon：**负载均衡的服务调用**组件，具有多种负载均衡调用策略；

Hystrix：**服务容错**组件，实现了**断路器**模式，为依赖服务的出错和延迟提供了容错能力；

Feign：基于Ribbon和Hystrix的**声明式服务调用**组件；

Zuul：**API网关**组件，对请求提供路由及过滤功能。



## 4.Eureka服务注册与发现

### Eureka基本的架构

- Eureka采用了C-S的架构设计，**EurekaServer是服务注册中心。**各个节点启动后，会在EurekaServer中进行注册，这样**Eureka Server的服务注册表中将储存所有可用服务节点的信息。**

- **其他微服务使用Eureka的客户端连接到EurekaServer并维持心跳连接。**系统的维护人员可以通过EurekaServer来监控系统中各个微服务是否正常运行，Springcloud 的一些其他模块 (比如Zuul) 可以通过EurekaServer来发现系统中的其他微服务，并执行相关的逻辑。

  ![image-20200926091541672](https://gitee.com/lzh_gitee/springboot_image/raw/master/img/image-20200926091541672.png)

### 三大角色

- Eureka Server：服务的注册与发现
- Provider：服务生产方，将自身服务注册到Eureka中，从而使服务消费方能够找到
- Consumer：服务消费方，从Eureka中获取注册服务列表，从而找到消费服务

### EureKa自我保护机制

当eureka server在一定时间内（默认是90秒）没有收到实例的心跳，便会把该实例从注册表中删除，但是，如果**短时间内丢失大量的心跳**（在15分钟内超过85%的节点都没有正常的心跳），便会触发eureka server的自我保护机制。此时：

- Eureka不再从注册列表中移除长时间没收到心跳的服务
- Eureka仍然能够接受新服务的注册和查询请求，但是不会同步到其他节点上 (即保证当前节点依然可用)
- 当网络稳定时，当前实例新的注册信息会被同步到其他节点中

**该保护机制的目的是避免网络连接故障，在发生网络故障时，微服务和注册中心之间无法正常通信，但服务本身是健康的，不应该注销该服务。**如果eureka因网络故障而把微服务误删了，那即使网络恢复了，该微服务也不会重新注册到eureka server了，因为**只有在微服务启动的时候才会发起注册请求，**后面只会发送心跳和服务列表请求，这样的话，该实例虽然是运行着，但永远不会被其它服务所感知。



### Eureka和Zookeeper区别

**1. CAP是什么?**

- C (Consistency) **强一致性**
- A (Availability) **可用性**
- P (Partition tolerance) **分区容错性**

**2. <font color=red>CAP理论的核心</font>**:一个分布式系统不可能同时满足一致性，可用性和分区容错性这三个需求。

**3. Eureka比Zookeeper好在哪里？**

由于分区容错性P在分布式系统中是必须要保证的，因此我们只能在C和A之间进行权衡。

**Zookeeper保证的是CP**

zookeeper会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。但选举leader的时间太长（30-120s），且**选举期间整个zookeeper集群是不可用的，这就导致在选举期间注册服务瘫痪。**虽然服务最终能够恢复，但是，漫长的选举过程会导致注册长期不可用。

**Eureka保证的是AP**

Eureka在设计时就优先保证可用性。**Eureka各个节点都是平等的**，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。Eureka的客户端在向某个Eureka注册时，如果发现连接失败，则会自动切换至其他节点，**只要有一台Eureka还在，就能保住注册服务的可用性，只不过查到的信息可能不是最新的，**除此之外，Eureka还有**自我保护机制。**

<font color=red>因此，Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪。</font>



### 注册中心挂了还可以继续通信吗？

能，有本地缓存。

### 没有注册中心能通信吗？

能，直连，消费者通过URL直接连上提供者。



## 5. Ribbon（基于客户端的负载均衡）

### Ribbon是什么？

- Ribbon的主要功能是提供客户端的负载均衡算法

  Ribbon在配置文件中列出后面所有的机器，Ribbon会自动基于某种规则（如简单轮询，随机连接或自定义负载均衡算法等）去连接这些机器。
- 负载均衡简单分类：
  - 集中式LB：即在服务的提供方和消费方之间使用独立的LB设施，如Nginx，由该设施负责把访问请求通过某种策略转发至服务的提供方。
  - 进程式LB：将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选出一个合适的服务器。
- <font color=red>Ribbon 属于进程式LB</font>

### Nginx与Ribbon的区别

Nginx在反向代理同时可以实现负载均衡，**Nginx服务器拦截客户端请求，然后采用负载均衡策略进行转发。**

**Ribbon是客户端负载均衡，从注册中心读取目标服务器信息，然后客户端根据负载均衡策略对服务直接访问，全程在客户端操作。**




## 6.Feign(基于服务端)

### Feign简介

Feign是声明式Web Service客户端，它让微服务之间的调用变得更简单，类似controller调用service。SpringCloud集成了Eureka和Ribbon，可以使用Feigin提供负载均衡的http客户端。

**只需要创建一个接口，然后添加注解即可**

调用微服务访问两种方法：

1. 微服务名字：Ribbon
2. 接口和注解：Feign

### Feign能干什么？

**Feign使编写Java Http客户端变得更容易。**前面在使用Ribbon + RestTemplate时，利用RestTemplate对Http请求的封装处理，形成了一套模板化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用。<font color=red>在Feign的实现下，我们只需要创建一个接口，并使用注解的方式来配置它 (类似以前Dao接口上标注Mapper注解，现在是一个微服务接口上面标注一个Feign注解即可</font>)，即可完成对服务提供方的接口绑定，**简化了使用Ribbon时，封装服务调用客户端的开发量。**

**Feign默认集成了Ribbon**，利用Ribbon维护了服务列表信息，并且通过轮询实现了客户端的负载均衡，而与Ribbon不同的是，通过Feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用。

### Feign和Ribbon如何选择？

根据个人习惯而定，如果喜欢REST风格使用Ribbon，如果喜欢面向接口风格使用Feign。



## 7. Hystrix

### 服务雪崩

多个微服务之间调用的时候，假设微服务A调用微服务B，微服务B又调用其他的微服务，这就是所谓的“扇出”，如果扇出的链路上**某个微服务的调用响应时间过长，或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃。**

**“断路器”是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控 ，向调用方返回一个服务预期的、可处理的备选响应 (Fallback) ，而不是长时间的等待或者抛出调用方法无法处理的异常，这样就可以保证服务调用方的线程不会被长时间占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。**

### 什么是Hystrix？

Hystrix是一个用于处理分布式系统的延迟和容错的开源库。在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，**Hystrix能够保证在一个依赖出问题时，不会导致整个体系服务失败，避免级联故障，提高分布式系统的可用性。**

Hystrix有四种**防雪崩**方式:

- **服务熔断**
- **服务降级**
- 服务隔离：Hystrix为隔离的服务开启一个独立的线程池，这样在高并发的情况下不会影响其他服务。
- 服务监控：在服务发生调用时,将每秒请求数、成功请求数等运行指标记录下来。

### 服务熔断

服务熔断是应对雪崩效应的一种微服务链路保护机制。**当调用链路的某个微服务不可用或者响应时间太长时，会进行服务熔断，不再有该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。**熔断机制的注解是：**<font color=red>@HystrixCommand</font>** 。

服务熔断解决如下问题： 

- 当所依赖的对象不稳定时，能够起到**快速失败**的目的；
- **快速失败后，能够根据一定的算法动态试探所依赖对象是否恢复。**

### 服务降级

#### 什么是服务降级

在服务器压力剧增的情况下，根据实际业务情况及流量，**对一些服务和页面有策略的不处理或换种简单的方式处理，从而保证核心业务正常或高效运作。**

降级的方式可以根据业务来，可以**延迟服务，**比如延迟给用户增加积分，只是放到一个缓存中，等服务平稳之后再执行 ；或者**在粒度范围内关闭服务，**比如关闭相关文章的推荐。

#### 自动降级分类

1. 超时降级
2. 失败次数降级
3. **故障降级：**比如要调用的远程服务挂掉了（网络故障、http服务返回错误的状态码、rpc服务抛出异常），则可以直接降级。降级后的处理方案有：默认值（库存服务挂了，返回默认现货）、兜底数据（广告挂了，返回提前准备好的一些静态页面）、缓存。
4. **限流降级：**秒杀或者抢购一些限购商品时，此时可能会因为访问量太大而导致系统崩溃，此时会使用限流来进行限制访问量，**当达到限流阈值，后续请求会被降级；**降级后的处理方案可以是：排队页面（将用户导流到排队页面等一会重试）、无货（直接告知用户没货了）、错误页（如活动太火爆了，稍后重试）。

### 区分熔断、降级、限流

熔断：依赖的下游服务故障触发熔断，避免引发本系统崩溃；系统自动执行和恢复；

降级：服务分优先级，牺牲非核心服务，保证核心服务稳定；从整体负荷考虑；

限流：限制并发的请求访问量，超过阈值则拒绝。



## 8. Zull路由网关

### 什么是zuul?

Zull包含了对请求的**路由**和**过滤**两个最主要功能：

**路由功能负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础，而过滤器功能则负责对请求的处理过程进行干预，是实现请求校验，服务聚合等功能的基础。Zuul和Eureka进行整合，Zuul将自己注册为Eureka下的应用，从Eureka中获得其他服务的消息，以后访问微服务都是通过Zuul跳转后获得。**

网关和过滤器的区别：网关是对所有服务的请求进行分析过滤，过滤器是对单个服务而言。
