# JVM

## 一、Java内存区域（运行时数据区域）



<center class="half">    
    <img src="https://cdn.jsdelivr.net/gh/javaguide-tech/image-host-github-stars-01@main/TeachYourselfCS/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png" width="350"/>    
    <img src="https://cdn.jsdelivr.net/gh/javaguide-tech/image-host-github-stars-01@main/TeachYourselfCS/2019-3Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9FJDK1.8.png" width="350"/> 
</center>



**线程私有：**程序计数器，虚拟机栈，本地方法栈

**线程共享：**堆，方法区



### 1.程序计数器

记录**正在执行的虚拟机字节码指令的地址**。

**程序计数器主要有两个作用：**

1. **字节码解释器**通过改变程序计数器来**依次读取指令，**从而实现代码的流程控制。
2. 在多线程的情况下，**为了线程切换后能恢复到正确的执行位置（因此程序计数器是私有的），**每条线程都需要有一个独立的程序计数器，各线程的计数器互不影响，独立存储。

### 2.虚拟机栈

**Java 内存可以分为堆（Heap）和栈 (Stack),其中栈就是现在说的虚拟机栈。** 

**每个 Java 方法在执行的同时会创建一个栈帧，**用于存储局部变量表、操作数栈、常量池引用等信息。**从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。**

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8442519f-0b4d-48f4-8229-56f984363c69.png" width="400px"> </div><br>



### 3.本地方法栈

与虚拟机栈类似，只不过**本地方法栈为本地方法服务。**

为了**保证线程中的局部变量不被别的线程访问到**，虚拟机栈和本地方法栈是线程私有的。

### 4.堆

**所有对象都在这里分配内存，是垃圾收集的主要区域。**

在 JDK 7 及之前，堆内存通常被分为下面三部分：

1. 新生代，分为：Eden 空间、From Survivor、To Survivor
2. 老年代
3. 永久代



![JVM堆内存结构-JDK7](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/322cf087600d49c89c3ae51ddab7e1a0~tplv-k3u1fbpfcp-watermark.image)

**堆不需要连续内存，并且可以动态增加其内存。**

### 5.方法区

**用于存放已被虚拟机加载的类信息（Class）、静态变量（static）、常量（final）、常量池。**

运行时常量池也是方法区的一部分，用于存放编译器生成的各种字面量（就是代码中定义的 static final 常量）和符号引用。

字面量： 接近于 Java 语言层面的常量概念，包括文本字符串，声明为 final 的常量值。

符号引用： 以一组符号来描述所引用的目标，包括类和接口的全限定名，字段的名称和描述符，方法的名称和描述符。

**方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。** 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。

### 6.元空间

JDK 8 之后方法区被彻底移除了，取而代之是元空间。类的元信息被存储在元空间中。元空间没有使用堆内存，而是**直接内存。**理论上系统可以使用的内存有多大，元空间就有多大，所以不会出现永久代存在时的内存溢出问题。

#### 为什么将方法区改为元空间？

HotSpot 虚拟机把方法区当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中。



## 二、垃圾收集

**垃圾收集主要是针对堆和方法区进行。**程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，不需要对这三个区域进行垃圾回收。



### 判断一个对象是否可被回收(判断一个对象是否死亡)

#### 1. 引用计数算法

为**对象**添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。在两个对象出现**循环引用**的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，Java 虚拟机不使用引用计数算法。

#### 2. 可达性分析算法

- **算法描述：**
  - 从 "GC Root" 对象作为起点开始向下搜索，不可达的对象被判为不可用。
  
  <div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/83d909d2-3858-4fe1-8ff4-16471db0b180.png" width="350px"> </div><br>
  
- **Java 中可作为 “GC Root” 的对象：**
  
  虚拟机栈中引用的对象；
  
  类的静态属性引用的对象；
  
  常量引用的对象；

```java
// 虚拟机栈中引用的对象
private int o1 = 100;

// 类的静态属性引用的对象
private static Person p1;

// 常量引用的对象
privare static final Person p2 = new Person();
```

即便如此，一个对象也不是一旦被判为不可达，就立即死去的，宣告一个的死亡需要经过两次标记过程。



### 宣告对象死亡的两次标记过程

当发现对象不可达后，该对象被第一次标记，并进行是否有必要执行 `finalize()` 方法的判断；

- 不需要执行：对象没有覆盖 `finalize()` 方法，或者 `finalize()` 方法已被执行过（`finalize()` 只被执行一次）；
- 需要执行：将该对象放置在一个队列中，并由一个较低级别的线程去执行`finalize()`方法。

稍后GC会对此队列进行第二次标记，如果发现依旧从GC roots不可达，那么此对象要被真的回收了。

**finalize()方法是对象逃脱死亡的最后一次机会。如果对象可以在此方法中将自己建立起与GC roots 的可达性，也就是有其他人引用了此对象，那么就可免于清理。**



### 方法区的回收

永久代的 GC 主要回收：**废弃常量** 和 **无用的类**。

- 废弃常量：例如一个字符串 "abc"，当没有任何引用指向 "abc" 时，它就是废弃常量了。

- 无用的类：同时满足以下 3 个条件的类：
  - 该类的所有实例已被回收，堆中不存在该类的任何实例；
  - 该类的 Class 对象没有被任何地方引用，即无法在任何地方通过反射访问该类的方法。
  - 加载该类的 Classloader 已被回收；
  
  虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。



### 引用类型（强软弱虚）

#### 1. 强引用

**被强引用关联的**对象**不会**被回收。

使用 new 一个新对象的方式来创建强引用。

```java
Object obj = new Object();
```

#### 2. 软引用

被软引用关联的对象只有在**内存不够**的情况下才会被回收。

使用 SoftReference 类来创建软引用。

```java
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;  // 使对象只被软引用关联
```

在程序设计中使用软引用的情况较多，这是因为**软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出等问题的产生**。软引用可用来实现内存敏感的高速缓存。一般很少使用弱引用与虚引用。

#### 3. 弱引用

被弱引用关联的对象**一定会**被回收，也就是说**它只能存活到下一次垃圾回收发生之前。**

使用 WeakReference 类来创建弱引用。

#### 4. 虚引用

又称为幽灵引用或者幻影引用，**为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。**一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。**虚引用主要用来跟踪对象被垃圾回收的活动**。



### 垃圾收集算法

#### 1. 标记 - 清除（Mark Sweep）

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/005b481b-502b-4e3f-985d-d043c2b330aa.png" width="400px"> </div><br>

在**标记阶段，**程序会检查每个对象是否为**活动对象，**如果是活动对象，则程序会在对象头部打上标记。

**在清除阶段，会进行对象回收并取消标志位。**回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。

不足：

- **会产生大量不连续的内存碎片，导致无法给大对象分配内存。**
- **需要进行两次扫描，标记一次，清除一次，效率不高；**

#### 2. 标记 - 整理

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ccd773a5-ad38-4022-895c-7ac318f31437.png" width="400px"> </div><br>

**让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。**

优点:**不会产生内存碎片。**

不足:**需要移动大量对象，处理效率比较低。**

#### 3. 复制

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b2b77b9e-958c-4016-8ae5-9c6edd83871e.png" width="400px"> </div><br>

**将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。**

**不足：只使用了内存的一半，适合GC过后只有少量对象存活的新生代。。**

现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。

HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。

#### 4. 分代收集

**现在的商业虚拟机采用分代收集算法**，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。

一般将堆分为新生代和老年代。

- **新生代使用：复制算法**
- **老年代使用：标记 - 清除 或者 标记 - 整理 算法**

在**新生代**中，**每次收集都会有大量对象死去，**所以可以选择复制算法，只需要付出**少量对象的复制成本**就可以完成每次垃圾收集。而**老年代**的对象存活几率是比较高的，而且**没有额外的空间对它进行分配担保，**所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。



### 7个垃圾收集器

串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。**除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。**

#### 1. CMS 收集器（重点）

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/62e77997-6957-4b68-8d12-bfd609bb2c68.jpg" width=""/> </div><br>

**CMS（Concurrent Mark Sweep），Mark Sweep ：标记 - 清除算法。**

**作用于老年代。**

CMS收集器是一种以**获取最短回收停顿时间**为目标的收集器。它非常符合在注重用户体验的应用上使用。

**具有以下缺点：**

- **吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。**
- **标记 - 清除算法导致空间碎片。**往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象。
- **无法处理浮动垃圾。**浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。

分为以下四个流程：

- 初始标记：标记 GC Roots 能直接关联到的对象，速度很快，需要停顿。
- 并发标记：进行 GC Roots 跟踪的过程，它在整个回收过程中耗时最长，不需要停顿。
- 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。
- 并发清除：不需要停顿。

在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。

#### 2. G1 收集器（重点）

G1（Garbage-First），它是一款**面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。**

其它收集器进行收集的范围都是整个新生代或者老年代，而 **G1 可以直接对新生代和老年代一起回收。**

**G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。**

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9bbddeeb-e939-41f0-8e8e-2b1a0aa7e0a7.png" width="600"/> </div><br>

通过引入 Region 的概念，从而**将原来的一整块内存空间划分成多个小空间，使得每个小空间可以单独进行垃圾回收。**这种划分方法带来了很大的**灵活性。**

**可预测的停顿时间模型：**通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。

特点：

- **基于标记-整理算法，不产生内存碎片。**

- **可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。**

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f99ee771-c56f-47fb-9148-c0036695b5fe.jpg" width=""/> </div><br>

G1 收集器的运作大致可划分为以下几个步骤：

- 初始标记
- 并发标记
- 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，这阶段需要停顿线程，但是可并行执行。
- **筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。**此阶段其实也可以做到与用户程序一起并发执行。



### Serial / ParNew 搭配 Serial Old 收集器

![image-20220420164838109](C:\Users\黄睿楠\AppData\Roaming\Typora\typora-user-images\image-20220420164838109.png)



Serial 收集器是虚拟机在 Client 模式下的默认新生代收集器，它的优势是简单高效，在单 CPU 模式下很牛。

ParNew 收集器就是 Serial 收集器的多线程版本，虽然除此之外没什么创新之处，但它却是许多运行在 Server 模式下的虚拟机中的首选新生代收集器，因为除了 Serial 收集器外，只有它能和 CMS 收集器搭配使用。

### Parallel 搭配 Parallel Scavenge 收集器

其他收集器关注于缩短垃圾收集时用户线程的停顿时间，而 **Parallel Scavenge 收集器的目的是达到一个可控的吞吐量。**因此，Parallel Scavenge 收集器不管是新生代还是老年代都是**多个线程同时进行垃圾收集，**十分适合于应用在**注重吞吐量以及 CPU 资源敏感的场合。**

> 吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )



## 三、内存分配与回收策略

### Minor GC 和 Full GC

- Minor GC：回收**新生代**，当 Eden 空间满时，就将触发一次 Minor GC。因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。

- Full GC：**主要发生在老年代，**老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。



### 内存分配策略

#### 1. 对象优先在 Eden 分配

大多数情况下，对象在新生代 Eden 上分配，**当 Eden 空间不够时，发起 Minor GC。**

#### 2. 大对象直接进入老年代

大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。

**目的：** 因为新生代采用的是复制算法收集垃圾，大对象直接进入老年代可以避免在 Eden 区和 Survivor 区发生大量的内存复制。

#### 3. 长期存活的对象进入老年代

为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄 MaxTenuringThreshold  则移动到老年代中。

#### 4. 动态对象年龄判定

虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中所有相同年龄的对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。

#### 5. 空间分配担保

新生代采用的是复制算法清理内存，每一次 Minor GC，虚拟机会将 Eden 区和其中一块 Survivor 区的存活对象复制到另一块 Survivor 区，但 **当出现大量对象在一次 Minor GC 后仍然存活的情况时，Survivor 区可能容纳不下这么多对象，此时，就需要老年代进行分配担保，即将 Survivor 无法容纳的对象直接进入老年代。**



### Full GC 的触发条件

#### 1. 老年代空间不足

老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。

为了避免以上原因引起的 Full GC，尽量不要创建过大的对象以及数组。除此之外，可以调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以调大对象进入老年代的年龄，让对象在新生代多存活一段时间。

#### 2. 空间分配担保失败

使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。

#### 3. Concurrent Mode Failure

执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致），便会报 Concurrent Mode Failure 错误，并触发 Full GC。

#### 4. 调用 System.gc()

只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。



## 四、类加载机制

### 类的生命周期

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/335fe19c-4a76-45ab-9320-88c90d6a0d7e.png" width="600px"> </div><br>



### 类加载过程

包含了**加载、验证、准备、解析、初始化**这 5 个阶段。

**类是在运行期间（例如使用 new 实例化对象、读取或设置一个类的非final的 static 字段、调用类的静态方法）第一次使用时动态加载的（lazy-load），而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。**

#### 1. 加载

加载过程完成以下三件事：

- 通过类的完全限定名称获取定义该类的Class文件，读进内存。
- 将 Class 表示的静态存储结构转换为运行时的存储结构。
- 在内存中生成一个代表该类的 Class 对象。

#### 2. 验证

确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，包括语义分析，字节码验证等。

#### 3. 准备

准备阶段为类（static）变量分配内存并设置初始值，使用的是方法区的内存。

初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。

```java
public static int value = 123;
```

如果类变量是常量，那么它将初始化为表达式所定义的值。例如下面的常量 value 被初始化为 123 而不是 0。

```java
public static final int value = 123;
```

#### 4. 解析

**将常量池的符号引用替换为直接引用的过程。**

在此之前，常量池中的引用不一定存在内存，解析过之后，可以保证常量池中的引用在内存中一定存在。

其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。

#### 5. 初始化

初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行**构造方法**的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员制定的主观计划去初始化类变量和其它资源。



### 如何判断两个类 “相等”

类本身相等（同一个.class文件）。

使用同一个类加载器进行加载。因为每一个类加载器都拥有一个独立的类名称空间。

**判断相等的方法：**

类的 Class 对象的 equals() 方法、isInstance() 方法、isAssignableFrom() 方法的返回结果为 true，使用 instanceof 关键字做对象所属关系判定结果为 true。



### 双亲委派模型

应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。

**类加载器之间的层次关系，称为双亲委派模型**。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0dd2d40a-5b2b-4d45-b176-e75a4cd4bdbf.png" width="500px"> </div><br>

#### 1. 工作过程

**一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。**

#### 2. 好处

**自己写的类库同名类不会覆盖类库的类**

例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。



## 五、对象的创建（遇到一条 new 指令时）

![img](https://images.xiaozhuanlan.com/photo/2019/73f30855e4cdfd6f2e944398e97981a2.png)

#### 初始化零值

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值，这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

#### 设置对象头

初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。** 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

#### 执行 init 方法

在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，`<init>` 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。



## 六、OOM异常

内存泄漏：指程序运行过程中**分配内存给临时变量，用完之后却没有被GC回收，始终占用着内存**，既不能被使用也不能分配给其他程序，于是就发生了内存泄漏。

内存溢出：指**程序运行过程中申请的内存大于系统能够提供的内存，导致无法申请到足够的内存**，于是就发生了内存溢出。
