# JVM



## 一、Java内存区域（运行时数据区域）



<center class="half">    
    <img src="https://cdn.jsdelivr.net/gh/javaguide-tech/image-host-github-stars-01@main/TeachYourselfCS/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png" width="350"/>    
    <img src="https://cdn.jsdelivr.net/gh/javaguide-tech/image-host-github-stars-01@main/TeachYourselfCS/2019-3Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9FJDK1.8.png" width="350"/> 
</center>



**线程私有：**程序计数器，虚拟机栈，本地方法栈

**线程共享：**堆，方法区



### 1.程序计数器

记录**正在执行的虚拟机字节码指令的地址**（如果正在执行的是本地方法则为空）。

**程序计数器主要有两个作用：**

1. **字节码解释器**通过改变程序计数器来**依次读取指令，**从而实现代码的流程控制，如：顺序执行、选择、循环。
2. 在多线程的情况下，**为了线程切换后能恢复到正确的执行位置（因此程序计数器是私有的），**每条线程都需要有一个独立的程序计数器，各线程的计数器互不影响，独立存储。

程序计数器的生命周期随着线程的创建而创建，随着线程的结束而死亡。

### 2.虚拟机栈

**Java 内存可以分为堆（Heap）和栈 (Stack),其中栈就是现在说的虚拟机栈。** 

**每个 Java 方法在执行的同时会创建一个栈帧，**用于存储局部变量表、操作数栈、常量池引用等信息。**从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。**

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8442519f-0b4d-48f4-8229-56f984363c69.png" width="400px"> </div><br>

局部变量表：存放方法参数和局部变量的区域。

虚拟机栈的生命周期和线程相同。

### 3.本地方法栈

与虚拟机栈类似，只不过**本地方法栈为本地方法服务。**

本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、常量池引用等信息。

为了**保证线程中的局部变量不被别的线程访问到**，虚拟机栈和本地方法栈是线程私有的。



### 4.堆

**所有对象都在这里分配内存，是垃圾收集的主要区域。**

在 JDK 7 及之前，堆内存通常被分为下面三部分：

1. 新生代(Young Generation)，**新生代分为：Eden 空间、From Survivor、To Survivor** 
2. 老年代(Old Generation)
3. 永久代(Permanent Generation)

在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放类信息（Class）、静态变量（static）、常量（final）等。



![JVM堆内存结构-JDK7](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/322cf087600d49c89c3ae51ddab7e1a0~tplv-k3u1fbpfcp-watermark.image)

**堆不需要连续内存，并且可以动态增加其内存**，增加失败会抛出 OutOfMemoryError 异常。

### 5.方法区

**用于存放已被虚拟机加载的类信息（Class）、静态变量（static）、常量（final）、常量池。**

运行时常量池也是方法区的一部分，用于存放编译器生成的各种字面量（就是代码中定义的 static final 常量）和符号引用。

**字面量：** 接近于 Java 语言层面的常量概念，包括

- 文本字符串
- 声明为 final 的常量值

**符号引用：** 以一组符号来描述所引用的目标，包括

- 类和接口的全限定名
- 字段的名称和描述符
- 方法的名称和描述符

**方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。** 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。

### 6.元空间

JDK 8 之后方法区被彻底移除了，取而代之是元空间。类的元信息被存储在元空间中。元空间没有使用堆内存，而是**直接内存。**理论上系统可以使用的内存有多大，元空间就有多大，所以不会出现永久代存在时的内存溢出问题。

#### 为什么将方法区改为元空间？

HotSpot 虚拟机把方法区当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中。



## 二、垃圾收集

**垃圾收集主要是针对堆和方法区进行。**程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。



### 判断一个对象是否可被回收(判断一个对象是否死亡)

#### 1. 引用计数算法

为**对象**添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。在两个对象出现**循环引用**的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。

#### 2. 可达性分析算法

- **算法描述：**
  - 从 "GC Root" 对象作为起点开始向下搜索，走过的路径称为引用链（Reference Chain）；
  - 从 "GC Root" 开始，不可达的对象被判为不可用。
- **Java 中可作为 “GC Root” 的对象：**
  - 栈中（本地变量表中的reference）
    - 虚拟机栈中，栈帧中的本地变量表引用的对象；
    - 本地方法栈中，JNI 引用的对象（native方法）；
  - 方法区中
    - 类的静态属性引用的对象；
    - 常量引用的对象；

即便如此，一个对象也不是一旦被判为不可达，就立即死去的，宣告一个的死亡需要经过两次标记过程。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/83d909d2-3858-4fe1-8ff4-16471db0b180.png" width="350px"> </div><br>



### 宣告对象死亡的两次标记过程

当发现对象不可达后，该对象被第一次标记，并进行是否有必要执行 `finalize()` 方法的判断；

- 不需要执行：对象没有覆盖 `finalize()` 方法，或者 `finalize()` 方法已被执行过（`finalize()` 只被执行一次）；
- 需要执行：将该对象放置在一个队列中，并由一个较低级别的线程去执行此方法。

稍后GC会对此队列进行第二次标记，如果发现依旧从GC roots不可达，那么此对象要被真的回收了。

也就是说，finalize()方法是对象逃脱死亡的最后一次机会。如果对象可以在此方法中将自己建立起与GC roots 的可达性，也就是有其他人引用了此对象，那么就可被免于清理。



### 方法区的回收

永久代的 GC 主要回收：**废弃常量** 和 **无用的类**。

- 废弃常量：例如一个字符串 "abc"，当没有任何引用指向 "abc" 时，它就是废弃常量了。

- 无用的类：同时满足以下 3 个条件的类。
  - 该类的所有实例已被回收，Java 堆中不存在该类的任何实例；
  - 加载该类的 Classloader 已被回收；
  - 该类的 Class 对象没有被任何地方引用，即无法在任何地方通过反射访问该类的方法。
  
  虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。



### 引用类型（强软弱虚）

#### 1. 强引用

**被强引用关联的**对象**不会**被回收。

使用 new 一个新对象的方式来创建强引用。

```java
Object obj = new Object();
```

#### 2. 软引用

被软引用关联的对象只有在**内存不够**的情况下才会被回收。

使用 SoftReference 类来创建软引用。

```java
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;  // 使对象只被软引用关联
```

在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为**软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生**。软引用可用来实现内存敏感的高速缓存。

#### 3. 弱引用

被弱引用关联的对象**一定会**被回收，也就是说**它只能存活到下一次垃圾回收发生之前。**

使用 WeakReference 类来创建弱引用。

#### 4. 虚引用

又称为幽灵引用或者幻影引用，**为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。**一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。**虚引用主要用来跟踪对象被垃圾回收的活动**。



### 垃圾收集算法

#### 1. 标记 - 清除（Mark Sweep）

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/005b481b-502b-4e3f-985d-d043c2b330aa.png" width="400px"> </div><br>

在**标记阶段，**程序会检查每个对象是否为**活动对象，**如果是活动对象，则程序会在对象头部打上标记。

**在清除阶段，会进行对象回收并取消标志位，回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。**

在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。

不足：

- **需要进行两次扫描，标记一次，清除一次，效率不高；**
- **会产生大量不连续的内存碎片，导致无法给大对象分配内存。**

#### 2. 标记 - 整理

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ccd773a5-ad38-4022-895c-7ac318f31437.png" width="400px"> </div><br>

**让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。**

优点:**不会产生内存碎片。**

不足:**需要移动大量对象，处理效率比较低。**

#### 3. 复制

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b2b77b9e-958c-4016-8ae5-9c6edd83871e.png" width="400px"> </div><br>

**将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。**

**不足：只使用了内存的一半，适合GC过后只有少量对象存活的新生代。。**

现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。

HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。

#### 4. 分代收集

**现在的商业虚拟机采用分代收集算法**，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。

一般将堆分为新生代和老年代。

- **新生代使用：复制算法**
- **老年代使用：标记 - 清除 或者 标记 - 整理 算法**

在**新生代**中，**每次收集都会有大量对象死去，**所以可以选择复制算法，只需要付出**少量对象的复制成本**就可以完成每次垃圾收集。而**老年代**的对象存活几率是比较高的，而且**没有额外的空间对它进行分配担保，**所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。



### 7个垃圾收集器

串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。**除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。**

#### 1. CMS 收集器（重点）

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/62e77997-6957-4b68-8d12-bfd609bb2c68.jpg" width=""/> </div><br>

**CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。**

**作用于老年代。**

CMS收集器是一种以**获取最短回收停顿时间**为目标的收集器。它非常符合在注重用户体验的应用上使用。

**分为以下四个流程：**

- **初始标记：标记 GC Roots 能直接关联到的对象，速度很快，需要停顿。**
- **并发标记：进行 GC Roots 跟踪的过程，它在整个回收过程中耗时最长，不需要停顿。**
- **重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。**
- **并发清除：不需要停顿。**

在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。

**具有以下缺点：**

- **吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。**
- **标记 - 清除算法导致空间碎片。**往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。
- **无法处理浮动垃圾。**浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。

#### 2. G1 收集器（重点）

G1（Garbage-First），它是一款**面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。**

其它收集器进行收集的范围都是整个新生代或者老年代，而 **G1 可以直接对新生代和老年代一起回收。**

**G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。**

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9bbddeeb-e939-41f0-8e8e-2b1a0aa7e0a7.png" width="600"/> </div><br>

通过引入 Region 的概念，从而**将原来的一整块内存空间划分成多个小空间，使得每个小空间可以单独进行垃圾回收。**这种划分方法带来了很大的**灵活性，**使得**可预测的停顿时间模型**成为可能。**通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。**

每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在**做可达性分析的时候就可以避免全堆扫描。**

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f99ee771-c56f-47fb-9148-c0036695b5fe.jpg" width=""/> </div><br>

如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：

- 初始标记
- 并发标记
- 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，这阶段需要停顿线程，但是可并行执行。
- **筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。**

特点：

- **基于标记-整理算法，不产生内存碎片。**

- **可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。**



### Serial / ParNew 搭配 Serial Old 收集器

![image-20220420164838109](C:\Users\黄睿楠\AppData\Roaming\Typora\typora-user-images\image-20220420164838109.png)



Serial 收集器是虚拟机在 Client 模式下的默认新生代收集器，它的优势是简单高效，在单 CPU 模式下很牛。

ParNew 收集器就是 Serial 收集器的多线程版本，虽然除此之外没什么创新之处，但它却是许多运行在 Server 模式下的虚拟机中的首选新生代收集器，因为除了 Serial 收集器外，只有它能和 CMS 收集器搭配使用。

### Parallel 搭配 Parallel Scavenge 收集器

它们的关注点与其他收集器不同，其他收集器关注于尽可能缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 收集器的目的是达到一个可控的吞吐量。

> 吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )

因此，Parallel Scavenge 收集器不管是新生代还是老年代都是多个线程同时进行垃圾收集，十分适合于应用在注重吞吐量以及 CPU 资源敏感的场合。



## 三、内存分配与回收策略

### Minor GC 和 Full GC

- Minor GC：回收**新生代**，当 Eden 空间满时，就将触发一次 Minor GC。因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。

- Full GC：**主要发生在老年代，**老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。



### 内存分配策略

#### 1. 对象优先在 Eden 分配

大多数情况下，对象在新生代 Eden 上分配，**当 Eden 空间不够时，发起 Minor GC。**

#### 2. 大对象直接进入老年代

大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。

**目的：** 因为新生代采用的是复制算法收集垃圾，大对象直接进入老年代可以避免在 Eden 区和 Survivor 区发生大量的内存复制。

#### 3. 长期存活的对象进入老年代

为对象定义年龄计数器，**对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。**

#### 4. 动态对象年龄判定

虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，**如果在 Survivor 中所有相同年龄的对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。**

#### 5. 空间分配担保

我们知道，新生代采用的是复制算法清理内存，每一次 Minor GC，虚拟机会将 Eden 区和其中一块 Survivor 区的存活对象复制到另一块 Survivor 区，但 **当出现大量对象在一次 Minor GC 后仍然存活的情况时，Survivor 区可能容纳不下这么多对象，此时，就需要老年代进行分配担保，即将 Survivor 无法容纳的对象直接进入老年代。**

这么做有一个前提，就是老年代得装得下这么多对象。可是在一次 GC 操作前，虚拟机并不知道到底会有多少对象存活，所以空间分配担保有这样一个判断流程：

- 发生 Minor GC 前，虚拟机先检查老年代的最大可用连续空间是否大于新生代所有对象的总空间；
  - 如果大于，Minor GC 一定是安全的；
  - 如果小于，虚拟机会查看 HandlePromotionFailure 参数，看看是否允许担保失败；
    - 允许失败：尝试着进行一次 Minor GC；
    - 不允许失败：进行一次 Full GC；
- 不过 JDK 6 Update 24 后，HandlePromotionFailure 参数就没有用了，规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行 Minor GC，否则将进行 Full GC。



### Full GC 的触发条件

**当 Eden 空间满时，就将触发一次 Minor GC。**而 Full GC 则相对复杂，有以下条件：

#### 1. 调用 System.gc()

只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。

#### 2. 老年代空间不足

老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。

为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以调大对象进入老年代的年龄，让对象在新生代多存活一段时间。

#### 3. JDK 1.7 及以前的永久代空间不足

当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。

为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。

#### 4. 空间分配担保失败

使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。

#### 5. Concurrent Mode Failure

执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。



## 四、类加载机制

### 类的生命周期

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/335fe19c-4a76-45ab-9320-88c90d6a0d7e.png" width="600px"> </div><br>

包括以下 7 个阶段：

-   **加载（Loading）**  
-   **验证（Verification）**  
-   **准备（Preparation）**  
-   **解析（Resolution）**  
-   **初始化（Initialization）**  
- 使用（Using）
- 卸载（Unloading）



### 类加载过程

包含了**加载验证准备解析初始化**这 5 个阶段。

**类是在运行期间（例如使用 new 实例化对象、读取或设置一个类的非final的 static 字段、调用类的静态方法）第一次使用时动态加载的（lazy-load），而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。**

#### 1. 加载

加载过程完成以下三件事：

- 通过类的完全限定名称获取定义该类的二进制字节流（Class 文件是一组以字节为基础单位的二进制流，所以就是将 .class 文件读进内存）。
- 将该字节流表示的静态存储结构转换为运行时的存储结构。
- 在内存中生成一个代表该类的 Class 对象。

#### 2. 验证

确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求。

**4 个验证过程（了解）：**

- 文件格式验证：是否符合 Class 文件格式规范，验证文件开头 4 个字节是不是 “魔数” `0xCAFEBABE`
- 元数据验证：保证字节码描述信息符合 Java 规范（语义分析）
- 字节码验证：程序语义、逻辑是否正确（通过数据流、控制流分析）
- 符号引用验证：对类自身以外的信息（常量池中的符号引用）进行匹配性校验

#### 3. 准备

准备阶段为类（static）变量分配内存并设置初始值，使用的是方法区的内存。

初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。

```java
public static int value = 123;
```

如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。

```java
public static final int value = 123;
```

#### 4. 解析

将常量池的符号引用替换为直接引用的过程。

在此之前，常量池中的引用是不一定存在的，解析过之后，可以保证常量池中的引用在内存中一定存在。

- 符号引用：以一组符号描述所引用的对象（如对象的全类名），引用的目标不一定存在于内存中。
- 直接引用：直接指向被引用目标在内存中的位置的指针等，也就是说，引用的目标一定存在于内存中。

其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。

#### 5. 初始化

初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行**构造方法**的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。



### 如何判断两个类 “相等”

**相等的要求：**

类本身相等（同一个.class文件）。

使用同一个类加载器进行加载。因为每一个类加载器都拥有一个独立的类名称空间。

**判断相等的方法：**

类的 Class 对象的 equals() 方法、isInstance() 方法、isAssignableFrom() 方法的返回结果为 true，使用 instanceof 关键字做对象所属关系判定结果为 true。



### 双亲委派模型

应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。

下图展示了**类加载器之间的层次关系，称为双亲委派模型**。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0dd2d40a-5b2b-4d45-b176-e75a4cd4bdbf.png" width="500px"> </div><br>

#### 1. 工作过程

**一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。**

#### 2. 好处

**自己写的类库同名类不会覆盖类库的类**

例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。



## 五、对象的创建（遇到一条 new 指令时）

![img](https://images.xiaozhuanlan.com/photo/2019/73f30855e4cdfd6f2e944398e97981a2.png)

#### Step1:类加载检查

虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

#### Step2:分配内存

在**类加载检查**通过后，接下来虚拟机将为新生对象**分配内存**。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**。

**内存分配的两种方式：（补充内容，需要掌握）**

选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的

![img](https://images.xiaozhuanlan.com/photo/2019/3af6db384fba7d42e2f9a07fb57b72d8.)

**内存分配并发问题（补充内容，需要掌握）**

在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：

- **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
- **TLAB：** 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配

#### Step3:初始化零值

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

#### Step4:设置对象头

初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。** 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

#### Step5:执行 init 方法

在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，`<init>` 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。



## 六、OOM异常

### Java 堆溢出

- 出现标志：`java.lang.OutOfMemoryError: Java heap space`

- 解决方法：

  - 先通过内存映像分析工具分析 Dump 出来的堆转储快照，确认内存中的对象是否是必要的，即分清楚是出现了内存泄漏还是内存溢出；
  - 如果是内存泄漏，通过工具查看泄漏对象到 GC Root 的引用链，定位出泄漏的位置；
  - 如果是内存溢出，检查虚拟机堆参数（-Xmx 和 -Xms）是否可以调大，检查代码中是否有哪些对象的生命周期过长，尝试减少程序运行期的内存消耗。

  内存泄漏：内存泄漏指程序运行过程中**分配内存给临时变量，用完之后却没有被GC回收，始终占用着内存**，既不能被使用也不能分配给其他程序，于是就发生了内存泄漏。

  内存溢出：简单地说内存溢出就是指**程序运行过程中申请的内存大于系统能够提供的内存，导致无法申请到足够的内存**，于是就发生了内存溢出。

### Java 虚拟机栈和本地方法栈溢出

- 单线程下，栈帧过大、虚拟机容量过小都不会导致 OutOfMemoryError，只会导致 StackOverflowError（栈会比内存先爆掉），一般多线程才会出现 OutOfMemoryError，因为线程本身要占用内存；
- 如果是多线程导致的 OutOfMemoryError，在不能减少线程数或更换 64 位虚拟机的情况，只能通过减少最大堆和减少栈容量来换取更多的线程。这个调节思路和 Java 堆出现 OOM 正好相反，Java 堆出现 OOM 要调大堆内存的设置值，而栈出现 OOM 反而要调小。
